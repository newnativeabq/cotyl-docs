# Timesheet Proof of Concept
Build a visual DAO Application with a limited set of framework restrictions as an exploratory exercise.  Note a DAO is a set of dApps. A visual DAO is a linked set of visual dApps.

The Visual DAO Framework project can be hard to coneptualize. To help us understand what a visual DAO can be and guide further discussion, we'll build one! 

Please note that all of this may change in the final framework!  This is still the proof of concept stage. We will build a production ready client-side application, distributed through IPFS, utilizing Dandelion APIs to deploy smart contracts on the Cardano network. 

## Design of Timesheet Application
We'll build from a core escrow smart contract that does the following:

* employee and employer agree on a contract payment amount
* either the employee or employer may submit the contract by filling in some public key details
* the employer may deposit the agreed upon amount and the contract continues to approval 'phases'
* the employee may then validate the amount within a certain time
* the employer may approve the payment within a certain time
* if everyone approves, the money is paid to the employee! else, the money is returned to the employer.

View a snapshot of the marlow contract [here!](./examples/images/escrow_contract_example.PNG)
Check out the [Marlow Plaground](https://alpha.marlowe.iohkdev.io/) to build your own smart contracts.

### The Client-Side Application Requirements
The client application (for employees and employers) must do the following:
* submit contracts
* review contract status
* allow employee to submit work for approval

### Early Diagrams
The Visual DAO framework does not replace upfront design and engineering.  Though we'll make some choices that limit how we can build the DAO in a sec, pictures are worth a thousand words. Let's draw a quick data flow diagram (DFD) and see how close the functioning thing comes.

![TimeSheet dApp DFD](https://github.com/newnativeabq/cotyl-docs/blob/4957a8ac86218094b7271dee2b4c3be2071bd9c3/docs/examples/images/timesheetdapplicationdfd.png)

Note only the bits in the middle are controlled by the DAO.  The external entities will have references and connections, but for obvious reasons, can't be forced to message the same way.  Future iterations will need to introduce better edge protection.

## Visual DAO Framework Restrictions V0.001
Let's set some engineering and templating restrictions to guide this pass.

### Deployment
We will deploy through github.  A centralized deployment strategy isn't great, but it will be discoverable, searchable, and serve our purposes this time out.  Future iterations will have more deployment options.  

Another issue is client side applications.  Both the cardano CLI and cardano node will need to be available.  We can use docker-compose to stand up these services for the time being.  This will not be a lightweight dApp.

### Node Templating
We have 4 nodes in our application.  Let's make some fun choices with how the framework will require layout.

1. We'll use python because it's fast to push a POC out with it.
2. We will enforce one .py file per node in a Nodes folder excepting:
3. Transforms can be shared, but all transforms will be one transform per .py file in a Transforms folder
4. Nodes can be given a common name, but will have names generated on setup/run command(s).

### Messaging
Data will be sent via protocol buffer between nodes.

All messages between nodes will have pre-defined .proto files that include some basic elements of provenance.  For a great runthrough of full the PROV Data Model check out the [PROV-JSON Serialization guide](https://www.w3.org/Submission/2013/SUBM-prov-json-20130424/).  We'll use a couple for now.  The full PROV data model is a tad onerous, but components are very useful for protected routes and ensuring operation sequence in disconnected compute environments.

We will track the following metadata with every message:
* Generation Expression (wasGeneratedBy(id, time))
* Usage Expression (used(id, time, transformationName))
* End Expression (wasEndedBy(id, transformationName))

We can get wild with code signatures enforcing data transformation integrity in untrusted environments, but we'll leave that for the real framework.


### Visualization
I've chosen the 'route' abstraction and DFD for a reason.  It makes edges easy to define.  An edge is nothing more than a message used by function (modify/append/validate) and passed to another function or ended.

In our example, we have the WebServer passing a message of type mTS (ends at submission, so define the fully flushed message message - transaction submission) generated by the client to the transaction builder for construction.  We can denote the WebServer function ws1 and the transaction builder function tb1.  An edge between them, then, is defined as tb1(ws1).  The edge between transaction submitter and transaction builder is similarly ts1(tb1) and every message send submission send to the CLI will be of the form ts1(tb1(ws1 mTS)).

But none of that really matters now.  **First** we need to get everything registering and initialse the dao.visualize() command.

## Next Steps
In the next post, we'll sketch out the directory, dump some folders, and get our nodes, internal and external, registering themselves.